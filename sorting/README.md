# Sorting

| 算法 | 平均时间复杂度 | 最好情况 | 最坏情况 | 空间复杂度 | 稳定性 |
| ---- | -------------- | -------- | -------- | ---------- | ------ |
| 冒泡 | O(n^2)         | O(n)     | O(n^2)   | O(1)       | 稳定   |
| 选择 | O(n^2)         | O(n^2)   | O(n^2)   | O(1)       | 不稳定 |
| 插入 | O(n^2)         | O(n)     | O(n^2)   | O(1)       | 稳定   |
| 归并 | O(nlogn)       | O(nlogn) | O(nlogn) | O(n)       | 稳定   |
| 快速 | O(nlogn)       | O(nlogn) | O(n^2)   | O(logn)    | 不稳定 |

## 1. Bubble Sort

冒泡排序是一种简单直接的排序方法，主要思路就是不断地遍历序列，比较相邻的元素并通过交换排序。

### 复杂度分析

时间复杂度为 O(n^2)，空间复杂度为 O(1).

### 进一步优化

1. 如果一次遍历没有产生任何交换，即说明数列已经有序，不需要再进行后面的遍历。
2. 在每一次遍历的过程中，可以记录下最后交换的位置，作为下次循环的终点。
3. 对于 `[2, 3, 4, 5, 6, 7, 1, 8]` 这种序列，从右往左冒泡会简单很多，基于这个逻辑就可以升级到鸡尾酒排序，即在冒泡的过程中交替切换左右方向。

## 2. Insertion Sort

插入排序是一种逻辑非常直观的排序算法，思路如下：

1. 将第一个元素看成是有序数列，后面的是未排序序列。
2. 从第二个元素开始，不断地加入到有序列中。记得加入过程应当是迁移有序列找到空位，而不是不断地向前交换，那样就变成冒泡排序了。

### 复杂度分析

时间复杂度为 O(n^2)，空间复杂度为 O(1).

## 3. Selection Sort

选择排序也是一种简单的排序方法，主要思路是先选出最小的元素放在首位，再从剩下的元素中选取最小的放在第二位，依次进行直到结束。

排序的过程也就是不断选择最小（或最大）元素的过程，所以叫做选择排序是很合适的。

一般来说是不稳定的，比如对于 `[3, 3, 2]` 这种序列，一开始的时候首位的 3 会被交换到最后，导致两个 3 的顺序被改变了。

不过理论上有实现也可以做到稳定，比如使用链表而不是数组。

> **有很多办法可以将任意排序算法变成稳定的，但是，往往需要额外的时间或者空间**。

### 复杂度分析

时间复杂度为 O(n^2)，空间复杂度为 O(1).

## 4. Shell Sort

希尔排序是由插入排序进化而来，插入排序对于有序、规模小的序列的排序是效率很高的，所以希尔排序的主要思路就是对数据不断地进行预处理，最后执行的还是直接插入排序的逻辑。

比如对于 `[3, 1, 8, 2, 7, 4, 6, 5]` 这个序列来说，两两分组，3 和 7, 1 和 4 都是一组，每组数字的间距是 4，即总长度的一半，也就是增量。对于这四组数字分别排序之后，再把增量减半，得到两组，`[3, 8, 7, 6], [1, 2, 4, 5]`，再次排序，最后增量减半为 1，再进行最后的排序。

这个过程中的排序逻辑也都是直接插入排序，所以说希尔排序可以看作是插入排序的改进版本。

由于分组的间隔逻辑可能导致重复的数字在排序完成之后调换前后顺序，所以希尔排序是不稳定的。

### 复杂度分析

希尔排序的复杂度和增量的选择相关，对于 Hibbard 增量时间复杂度可以达到 O(n^3/2)，而最坏情况下的时间复杂度仍然会是 O(n^2).

空间复杂度为 O(1).

## 5. Merge Sort

归并排序是一种非常高效的排序方式，采用了 Divide and Conquer 的方法，将序列不断二分，直到每个元素都被分开再两两组合。

### 复杂度分析

时间复杂度可以达到稳定的 O(nlogn)，而空间复杂度为 O(n)，因为需要新建一个同样大小的数组，再加上递归消耗空间为 logn，所以加起来为 O(n).

### 拓展

Python 中使用的一种叫 Timsort 的排序方法就是基于归并和插入排序的组合。它的好处在于先将序列划分为合理大小的部分，分别进行插入排序，最后再归并到一起，由于插入排序在小规模数列中效率很高，而归并排序的稳定性又很高，所以 Timsort 即使在最坏情况下也可以达到 O(nlogn)，而理想情况下的复杂度则是 O(n). 对于现实世界很多序列本身已经存在一定的顺序了，所以应用 Timsort 会获得很好的效果。

### 参考

- [Timsort](https://en.wikipedia.org/wiki/Timsort)

- [Sorting Algorithms in Python](https://realpython.com/sorting-algorithms-python/#the-merge-sort-algorithm-in-python)

## 6. Quick Sort

快速排序基于冒泡排序，并且结合了 Divide and Conquer 思想来实现高效排序。

整体思路是先选定一个基准元素，然后把剩余的部分分为大小两部分，接着再对这两部分分别进行基准元素的选取和大小部分的划分，直到排序结束。

> 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。

### 复杂度分析

平均时间复杂度为 O(nlogn)，但是在极端情况下，比如有序序列，会退化成 O(n^2).

空间复杂度为 O(logn)，因为需要使用递归或堆栈来实现。

### 进一步优化

1. 对于小规模数列可以选择插入排序，比如 15 个元素以内。
2. pivot 的选择，有三种方式：
  - 固定选取，比如最左侧元素
  - 随机选取，可以交换到最左侧以简化实现
  - 三数取中，从头中尾中取得中间大小的元素，是比较理想的选择
3. 对于重复元素的处理，不移动指针的做法
  - 单边快速排序：对于大量重复元素的情况会造成分出的两部分元素非常不均衡，性能偏低
  - 双路快速排序：对于重复元素仍然会进行排序处理，可以进一步优化
  - 三路快速排序：每次循环会把重复元素的部分单独分出来，不参与之后的排序

### 参考

- [关于复杂度分析](https://www.cnblogs.com/HDK2016/p/6876313.html)
- [针对重复元素的优化](https://segmentfault.com/a/1190000021726667)
